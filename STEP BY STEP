##由於Perl的語法非常活潑，使得程式在維護時特別棘手，因此寫註解成為一項很重要的工作。 
我建議你最好在每個副程式前面加上對這段副程式的描述，特別是需要傳遞的參數要註明清楚

##Reference
http://ind.ntou.edu.tw/~dada/cgi/Perlsynx.htm
http://irw.ncut.edu.tw/peterju/perl.html

#Esccape caracter important !!!!!!
$x="ls -l";
print "$x";             # Output ls -l
print "\$x";            # Output $x
print '$x';             # Output $x
print `$x`;             # Output files in this directory

#Fuxk  deserve variable and used meaning ex:$_ 
$_	The default input and pattern-searching space.
$digit	Contains the subpattern from a successful parentheses pattern match.
$.	The current input line number of last filehandle read.
$!	Contains the current value of errno.
$0	The name of the file of the Perl script.
@ARGV	The command line arguments issued when the script was started.
@_	The parameter array for subroutines.
%ENV	This associative array contains your current environment.

#special operate
~	Performs a 1s complement of the operator. This is a unary operator.
!=	Returns Ture if the two operands are not equal, False otherwise.
< = >	Returns -1 if the left operand is less than the right, +1 if is it greater than, and 0(False) otherwise.
&&	Performs a logical AND operation. If the left operand is True m then the right operator is not evaluated.
|	Returns the valueof the two operators bitwise ORed.
^	Returns the valueof the two operators bitwise XORed.
+=	Adds the value of the right-hand operand to the value of the left-hand operand.
-+	Subtracts the value of the right-hand operand to the value of the left-hand operand.
>>	Shifts the left operand right by the number of bits that is specified by the right operand.
<<	Shifts the left operand left by the number of bits that is specified by the right operand.


##LOOP

#For
compare three statment:
(A) for($i=0; $i<=10; $i++) {Code Segment}
(B) foreach $i (@array) {Code Segment}
(c) for $i (0..10) {Code Segment}

#While 
while($i<=10) {Code Segment}

#Do
do {Code Segment} while(Expression);

# Perl也有和C語言的break和continue一樣的指令，Perl叫它做 last 和 next (較口語化)。
# last是跳出現在所在的迴圈，next則是跳過下面的指令直接執行下一次的迴圈。
while(chomp($i=<STDIN>)) {
next if ($i == 5);
last unless ($i > 10);
}

#Open file    https://perldoc.perl.org/functions/open.html
open(my $fh, '<:encoding(UTF-8)', $filename)  若不爽用 <符號開檔會如何??

#Array 
my @array;
(1)my @array=qw(a b c d);
(2)my @array=("a","b","c","d");以上(1)等於(2)


#Hash Array alike map
(A)define diction
my %hash=("i1","aaa","i2","bbb","i3","ccc");

(B)change diction
$hash{'i1'}="aaa"; $hash{'i2'}="bbb"; $hash{'i3'}="ccc";

(C)拜訪diction by key& by value
foreach $key (keys %hash) {
print "$hash{$key}\n";
}
foreach $value (values %hash)
while(($key,$value)=each %hash)

## Filter and custom filter fumula
(A)m//gimosx
m命令可以讓你自訂pattern的分隔符號，而gimosx則是它的修飾選項
($host, $port, $file)=($url=~m|http://([^/:]+):{0,1}(\d*)(\S*)$|);
if $url="my.machine.tw:8080/cgi-bin/test.pl";
then ($host, $port, $file)=($1, $2, $3)
即$host="my.machine.tw"  =====> ([^/:]+)
$port=8080               =====> :{0,1}(\d*)
$file="/cgi-bin/test.pl" =====> (\S*)$

(B)s/PATTERN/REPLACEMENT/egimox  
egimox 其中分別為
e	Evaluate the right side as an expression.
g	Replace globally, i.e. all occurrences.
i	Do case-insensitive pattern matching.
m	Treat string as multiple lines.
o	Only compile pattern once.
s	Treat string as single line.
x	Use extended regular expressions.

$x =~ s/\s+//g
把所有的white space全部去除掉

$x =~ s/([^ ]*):*([^ ]*)/$2:$1/
把用":"分開的兩個欄位互相對調

$path =~ s|/usr/bin|/usr/local/bin|
它也可以讓你自訂分隔符號哦

(C)tr/SEARCHLIST/REPLACEMENTLIST/cds   這是也是取代的命令，和上一個不同的是SEARCHLIST和REPLACEMENTLIST只能是普通字串，而不是Regular Expression
$x =~ tr/this/that/
把"this"替換成"that"

$x =~ tr/a-z/A-Z/
把小寫字母全部替換成大寫字母

$count = $x =~ tr/*/*/
計算$x中有幾個"*"

